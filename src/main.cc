/* src/main.cc
 *
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007 by The University of York
 * Copyright 2007, 2009, 2011, 2012 by The University of Oxford
 * Copyright 2014, 2015 by Medical Research Council
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA
 */

#include <gtk/gtk.h>


#include "coot-setup-python.hh"
#include "python-classes.hh"

/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#include <sys/time.h>
#include <string.h> // strcmp

#include <iostream>

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif


// We are not using NLS yet.
// #ifndef WINDOWS_MINGW
// #define ENABLE_NLS
// #endif
// #ifdef DATADIR
// #endif // DATADIR

// #include <GL/glut.h> // for glutInit()

// #include "lbg/lbg.hh"

#include "interface.h"
#ifndef HAVE_SUPPORT_H
#define HAVE_SUPPORT_H
#include "support.h"
#endif /* HAVE_SUPPORT_H */

// not in the world of GTK4
// #include "globjects.h"

#include <vector>
#include <string>

#include <mmdb2/mmdb_manager.h>
#include "coords/mmdb-extras.h"
#include "coords/mmdb.h"
#include "coords/mmdb-crystal.h"

#include "clipper/core/test_core.h"
#include "clipper/contrib/test_contrib.h"

#include "utils/coot-utils.hh"
#include "coords/Cartesian.h"
#include "coords/Bond_lines.h"

#include "command-line.hh"

#include "graphics-info.h"
// Including python needs to come after graphics-info.h, because
// something in Python.h (2.4 - chihiro) is redefining FF1 (in
// ssm_superpose.h) to be 0x00004000 (Grrr).
// BL says:: and (2.3 - dewinter), i.e. is a Mac - Python issue
// since the follwing two include python graphics-info.h is moved up
//

#include "c-interface.h"
#include "c-interface-gtk-widgets.h"
#include "cc-interface.hh"
#include "c-interface-preferences.h"

// #include "coot-surface/rgbreps.h"

#include "coot-database.hh"

#ifdef USE_GUILE
#include <libguile.h>
#endif


// #include "c-inner-main.h"
#include "coot-glue.hh"

#include "rotate-translate-modes.hh"

#include "change-dir.hh"
#include "curlew.hh"

void show_citation_request();
void load_gtk_resources();
void setup_splash_screen();
void desensitive_scripting_menu_item_maybe(GtkWidget *window);
int setup_screen_size_settings();
void setup_application_icon(GtkWindow *window);
void setup_symm_lib();
void check_reference_structures_dir();
#include "boot-python.hh"

#ifdef USE_MYSQL_DATABASE
#include "mysql/mysql.h"
int setup_database();
#endif

#include "testing.hh" // for test_internal();

#include "scm-boot-guile.hh"

#include "widget-headers.hh" // put these somewhere else? better name? -------- GTK-FIME
#include "sound.hh"

#include "draw.hh" // for test_gtk3_adjustment_changed() - maybe that should go elsewhere?
#include "draw-2.hh"

#include "dynamic-menus.hh"

#include "widget-from-builder.hh"

GtkWidget*
my_create_splash_screen_window (void) {

#if (GTK_MAJOR_VERSION >= 4)
   GtkWidget *splash_screen_window = gtk_window_new();
#else
   GtkWidget *splash_screen_window = gtk_window_new(GTK_WINDOW_POPUP);
   gtk_window_set_position(GTK_WINDOW (splash_screen_window), GTK_WIN_POS_CENTER);
#endif
   gtk_window_set_title(GTK_WINDOW (splash_screen_window), "Coot-Splash");

#if (GTK_MAJOR_VERSION >=4)
   // gtk_window_set_type_hint(GTK_WINDOW (splash_screen_window), GDK_SURFACE_TYPE_HINT_SPLASHSCREEN);
#else
   gtk_window_set_type_hint(GTK_WINDOW (splash_screen_window), GDK_WINDOW_TYPE_HINT_SPLASHSCREEN);
#endif

   GtkWidget *image = create_pixmap(splash_screen_window, "coot-1.png");
   gtk_widget_show(image);

#if (GTK_MAJOR_VERSION >=4)
   // 20220531-PE How do I do this simple thing!?
#else
   gtk_container_add(GTK_CONTAINER(splash_screen_window), image);
#endif

   return splash_screen_window;
}


GtkWidget *do_splash_screen(const command_line_data &cld) {

   // 20220313-PE this runs before builder is set.

#if (GTK_MAJOR_VERSION >=4)
   return nullptr; // just do nothing for now.
#endif

   GtkWidget *splash_screen = 0;
   setup_splash_screen();

   if (cld.use_splash_screen) {
      if (graphics_info_t::use_graphics_interface_flag) {
         std::string f = cld.alternate_splash_screen_file_name;
         if (f.empty()) {
            splash_screen = my_create_splash_screen_window();
            // splash_screen = widget_from_builder("splash_screen_window");
            // std::cout << "-- in do_splash_screen() splash_screen set to " << splash_screen << std::endl;
         } else {
            splash_screen = create_splash_screen_window_for_file(f.c_str());
         }
         if (splash_screen) {
            gtk_widget_show(splash_screen);
         } else{
            std::cout << "ERROR:: in main() splash is null " << std::endl;
         }

#if (GTK_MAJOR_VERSION >=4)
#else
         while(gtk_main_iteration() == FALSE);
         while (gtk_events_pending()) {
            coot::usleep(3000);
            gtk_main_iteration();
         }
#endif
      }
   }
   return splash_screen;
}

void
setup_pixmap_directory() {

   // default location:
   std::string dir = coot::package_data_dir();
   std::string dir_2 = coot::util::append_dir_dir(dir, "glade");
   std::string pixmap_dir = coot::util::append_dir_dir(dir_2, "pixmaps");

   // over-ridden by user?
   char *s = getenv("COOT_PIXMAPS_DIR");
   if (s)
      pixmap_dir = s;
   add_pixmap_directory(pixmap_dir.c_str());

}




int
do_self_tests() {

   std::cout << "INFO:: Running internal self tests" << std::endl;
   // return true on success
   clipper::Test_core test_core;       bool result_core    = test_core();
   clipper::Test_contrib test_contrib; bool result_contrib = test_contrib();
   std::cout<<" INFO:: Test Clipper core   : "<<(result_core   ?"OK":"FAIL")<<std::endl;
   std::cout<<" INFO:: Test Clipper contrib: "<<(result_contrib?"OK":"FAIL")<<std::endl;
   // return 1 on success
   int gis = test_internal();
   int shell_exit_code = 1;
   if (result_core)
      if (result_contrib)
         if (gis == 1)
            shell_exit_code = 0;
   return shell_exit_code;

}

void on_glarea_realize(GtkGLArea *glarea);

// gboolean
// on_label_widget_key_controller_key_pressed(GtkEventControllerKey *controller,
//                                            guint                  keyval,
//                                            guint                  keycode,
//                                            guint                  modifiers,
//                                            GtkButton             *button) {

//    std::cout << "on_label_widget_controller_key_pressed()" << std::endl;
//    return gboolean(FALSE);
//  }



#include "widget-from-builder.hh"
#include "coot-application.hh"

int new_startup(int argc, char **argv);

// This main is used for both python/guile useage and unscripted.
int
main(int argc, char *argv[]) {

   new_startup(argc, argv);
   return 0;

   auto do_window_resizing_widgets = [] () {

                                        GtkWidget *box = widget_from_builder("main_window_resize_window_button_box");
#ifdef __APPLE__
                                        gtk_widget_show(box);
                                        GtkWidget *window = widget_from_builder("main_window");
                                        // 20220407-PE this causes a crash
                                        // gtk_window_set_has_resize_grip(GTK_WINDOW(main_window), FALSE);

                                        // this expands the window fully in height - I don't want that.
                                        // gtk_window_set_resizable(GTK_WINDOW(window), FALSE);
#else
                                        if (box)
                                           gtk_widget_hide(box);
#endif
                                     };

   int shell_exit_code = 0;

   graphics_info_t graphics_info;
   graphics_info.coot_is_a_python_module = false;

#ifdef ENABLE_NLS // not used currently in Gtk1. Gkt2, yes.
   //
   bindtextdomain (PACKAGE, PACKAGE_LOCALE_DIR);
   bind_textdomain_codeset (PACKAGE, "UTF-8");
   textdomain (PACKAGE);
#endif

#ifdef USE_LIBCURL
   curl_global_init(CURL_GLOBAL_NOTHING); // nothing extra (e.g. ssl or WIN32)
#endif

   command_line_data cld = parse_command_line(argc, argv);
   cld.handle_immediate_settings(); // sets graphics_info::use_graphics_interface_flag

#ifdef WITH_SOUND
   // test_sound(argc, argv);
#endif // WITH_SOUND

   if (cld.run_internal_tests_and_exit)
      shell_exit_code = do_self_tests();

   if (graphics_info_t::show_citation_notice == 1)
      show_citation_request();

   if (graphics_info_t::use_graphics_interface_flag) {
      // load_gtk_resources();
#if (GTK_MAJOR_VERSION >=4) || (GTK_MINOR_VERSION == 94)
      gtk_init();
#else
      gtk_init(&argc, &argv);
#endif

      // activate to force icons in menus; cannot get it to work with
      // cootrc. Bug?
      // seems to be neccessary to make sure the type is realized
      // and we use newer g_object_set instead of deprecated (gtk3)
      // gtk_settings_set_long_property

      // not sure what this does, but it's deprecated now
      // g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));

      // 20220528-PE goodbye
      // GLib-GObject-WARNING **: 13:33:53.701: g_object_set_is_valid_property: object class 'GtkSettings' has no property named 'gtk-menu-images'
      // g_object_set(gtk_settings_get_default(), "gtk-menu-images", TRUE, NULL);
      g_object_set(gtk_settings_get_default(), "gtk-application-prefer-dark-theme", TRUE, NULL);

   } else {
      coot::set_os_error_mode();
   }

   GtkWidget *splash = nullptr;

   if (graphics_info_t::use_graphics_interface_flag)
      splash = do_splash_screen(cld);

   setup_symm_lib();
   check_reference_structures_dir();

   graphics_info.init();

#if (GTK_MAJOR_VERSION >= 4)

   if (graphics_info_t::use_graphics_interface_flag) {
      // this should be the return value to the shell
      int status = start_using_application(argc, argv); // doesn't return until quit.
   } else {
      // start-up in command line mode
   }

#else
         
   if (graphics_info_t::use_graphics_interface_flag) {

      bool old_way_flag = true;
      if (cld.use_gtkbuilder)
         old_way_flag = false;

      setup_pixmap_directory();

      if (cld.use_gtkbuilder) {
         bool success = init_from_gtkbuilder();
         if (success) {
            setup_application_icon(GTK_WINDOW(graphics_info_t::get_main_window()));

            do_window_resizing_widgets();

            GtkWidget *glarea = graphics_info_t::glareas[0];
            // my_glarea_add_signals_and_events(glarea);
            gtk_widget_show(glarea);
            // on_glarea_realize(GTK_GL_AREA(glarea)); // hacketty hack. I don't know why realize is not called
                                                       // without this.

            // We need to connect the submenu to the menus (which are
            // accessible via window1)
            // GtkWidget *main_window = widget_from_builder("main_window");

            // create_initial_map_color_submenu(main_window);
            // create_initial_ramachandran_mol_submenu(main_window);
            // create_initial_sequence_view_mol_submenu(main_window);

            // 20220529-PE setting up python hangs at the moment

            // 20220609-PE remove this for now - causing startup hang in
            // g_registered_type_info_get_g_type() gdk_rgba_get_type() g_once_init_enter() g_cond_wait()
            // setup_python(argc, argv);

         } else {
            std::cout << "WARNING:: init_from_gtkbuilder() failed " << std::endl;
         }
      }

   }

   // Mac users often start somewhere where they can't write files
   //
   change_directory_maybe();

#if !defined(USE_GUILE) && !defined(USE_PYTHON)
   handle_command_line_data(cld);  // and add a flag if listener
                                   // should be started.
#endif

   if (splash)
      gtk_window_destroy(GTK_WINDOW(splash));

   // before we run the scripting, let's make default preferences
   make_preferences_internal_default();

   // this glade file is derived from an ancient coot. It doesn't have a
   // ligand builder menu item. Add this back when it does.
   //
   // add_ligand_builder_menu_item_maybe();             // FIXME

   // remove Curlew from the File menu with old compiler?
   remove_file_curlew_menu_item_maybe();

   // to start the graphics, we need to init glut and gtk with the
   // command line args.

   // desensitive_scripting_menu_item_maybe(window1);

   // Hack this in to get Python scripts to work - not sure where the correct place to put this is.
   //
#ifdef USE_PYTHON
   handle_command_line_data(cld);
#endif

#ifdef USE_GUILE
   // *Don't* run script from here (before we start guile!)
#else
   //but if ware are using python only, python has been set up before now
   //
   // these scripts are stored by handle_command_line_data()
   run_command_line_scripts();
#endif


   // control goes into my_wrap_scm_boot_guile and doesn't return
#ifdef USE_GUILE
   // Must be the last thing in this function, code after it does not get
   // executed (if we are using guile)
   //
   // std::cout << "------------------------------- into scm_boot_guile we go!" << std::endl;
   my_wrap_scm_boot_guile(argc, argv);
#endif


   // ==================== ususually not exectuted ========================

#if ! defined (USE_GUILE)
#ifdef USE_PYTHON

   if (graphics_info_t::use_graphics_interface_flag) {
#if (GTK_MAJOR_VERSION >=4)

      std::cout << "-------------------------------------------------------------------" << std::endl;
      std::cout << "                 a replacement for gtk_main() here " << std::endl;
      std::cout << "                 use GtkApplication" << std::endl;
      std::cout << "-------------------------------------------------------------------" << std::endl;

      // 20220604-PE but for now...
      while (g_list_model_get_n_items (gtk_window_get_toplevels ()) > 0)
         g_main_context_iteration (NULL, TRUE);

#else      
      gtk_main();
#endif

   } else {
      start_command_line_python_maybe(true, argc, argv);
   }

#else
   // not python or guile
   if (graphics_info_t::use_graphics_interface_flag)
#if (GTK_MAJOR_VERSION >=4)
#else      
      gtk_main();
#endif
#endif // USE_PYTHON

#endif // ! USE_GUILE

#endif // GTKApplication startup

   return shell_exit_code;
}

void desensitive_scripting_menu_item_maybe(GtkWidget *window1) {

   // it's not allowed to build coot without python and guile
}


void load_gtk_resources() {

#if 0
   std::string gtkrcfile = coot::package_data_dir();
   gtkrcfile += "/cootrc";

   // over-ridden by user?
   char *s = getenv("COOT_RESOURCES_FILE");
   if (s) {
      gtkrcfile = s;
   }

   std::cout << "Acquiring application resources from " << gtkrcfile << std::endl;
   gtk_rc_add_default_file(gtkrcfile.c_str()); // Deprecated - use GtkStyleContext
#endif
}


/*  ----------------------------------------------------------------------- */
/*            Amusing (possibly) little splash screen                       */
/*  ----------------------------------------------------------------------- */
void
setup_splash_screen() {

   // default location:
   std::string data_dir = coot::package_data_dir();
   std::string dir_2 = coot::util::append_dir_dir(data_dir, "glade");
   std::string splash_screen_pixmap_dir = coot::util::append_dir_dir(dir_2, "pixmaps");

   // over-ridden by user?
   char *s = getenv("COOT_PIXMAPS_DIR");
   if (s) {
      splash_screen_pixmap_dir = s;
   }

   if (false)
      std::cout << "INFO:: splash_screen_pixmap_dir " << splash_screen_pixmap_dir << std::endl;

   // now add splash_screen_pixmap_dir to the pixmaps_directories CList
   //
   add_pixmap_directory(splash_screen_pixmap_dir.c_str());

}



void
show_citation_request() {

   std::cout << "\n   If you have found this software to be useful, you are requested to cite:\n"
	     << "   Coot: model-building tools for molecular graphics" << std::endl;
   std::cout << "   Emsley P, Cowtan K" << std::endl;
   std::cout << "   ACTA CRYSTALLOGRAPHICA SECTION D-BIOLOGICAL CRYSTALLOGRAPHY\n";
   std::cout << "   60: 2126-2132 Part 12 Sp. Iss. 1 DEC 2004\n\n";

   std::cout << "   The reference for the REFMAC5 Dictionary is:\n";
   std::cout << "   REFMAC5 dictionary: organization of prior chemical knowledge and\n"
	     << "   guidelines for its use" << std::endl;
   std::cout << "   Vagin AA, Steiner RA, Lebedev AA, Potterton L, McNicholas S,\n"
	     << "   Long F, Murshudov GN" << std::endl;
   std::cout << "   ACTA CRYSTALLOGRAPHICA SECTION D-BIOLOGICAL CRYSTALLOGRAPHY " << std::endl;
   std::cout << "   60: 2184-2195 Part 12 Sp. Iss. 1 DEC 2004" << std::endl;

#ifdef HAVE_SSMLIB
    std::cout << "\n   If using \"SSM Superposition\", please cite:\n";

    std::cout << "   Secondary-structure matching (SSM), a new tool for fast\n"
	      << "   protein structure alignment in three dimensions" << std::endl;
    std::cout << "   Krissinel E, Henrick K" << std::endl;
    std::cout << "   ACTA CRYSTALLOGRAPHICA SECTION D-BIOLOGICAL CRYSTALLOGRAPHY" << std::endl;
    std::cout << "   60: 2256-2268 Part 12 Sp. Iss. 1 DEC 2004\n" << std::endl;
#endif // HAVE_SSMLIB

}


void
menutoolbutton_rot_trans_activated(GtkWidget *item, GtkPositionType pos) {

   // std::cout << "changing to zone type" << pos << std::endl;
   set_rot_trans_object_type(pos);
   do_rot_trans_setup(1);
   if (graphics_info_t::model_fit_refine_dialog) {
     update_model_fit_refine_dialog_menu(graphics_info_t::model_fit_refine_dialog);
   }
}

