/* src/main.cc
 *
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007 by The University of York
 * Copyright 2007, 2009, 2011, 2012 by The University of Oxford
 * Copyright 2014, 2015 by Medical Research Council
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA
 */

#include <gtk/gtk.h>


#include "coot-setup-python.hh"
#include "python-classes.hh"

#include "compat/coot-sysdep.h"

/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#include <sys/time.h>
#include <string.h> // strcmp

#include <iostream>

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif


// We are not using NLS yet.
// #ifndef WINDOWS_MINGW
// #define ENABLE_NLS
// #endif
// #ifdef DATADIR
// #endif // DATADIR

// #include <GL/glut.h> // for glutInit()

// #include "lbg/lbg.hh"

#include "interface.h"
#ifndef HAVE_SUPPORT_H
#define HAVE_SUPPORT_H
#include "support.h"
#endif /* HAVE_SUPPORT_H */


#include <sys/types.h> // for stating
#include <sys/stat.h>

#ifndef _MSC_VER
#include <unistd.h>
#else
#define PKGDATADIR "C:/coot/share"
#endif

#include "globjects.h"

#include <vector>
#include <string>

// #include <mmdb2/mmdb_manager.h>
// #include "coords/mmdb-extras.h"
// #include "coords/mmdb.h"
// #include "coords/mmdb-crystal.h"

#include "clipper/core/test_core.h"
#include "clipper/contrib/test_contrib.h"

#include "utils/coot-utils.hh"
#include "coords/Cartesian.h"
#include "coords/Bond_lines.h"

#include "command-line.hh"

#include "graphics-info.h"
// Including python needs to come after graphics-info.h, because
// something in Python.h (2.4 - chihiro) is redefining FF1 (in
// ssm_superpose.h) to be 0x00004000 (Grrr).
// BL says:: and (2.3 - dewinter), i.e. is a Mac - Python issue
// since the follwing two include python graphics-info.h is moved up
//
#if defined (WINDOWS_MINGW)
#include <locale.h>
#ifdef DATADIR
#undef DATADIR
#endif // DATADIR
#endif
#include "compat/sleep-fixups.h"

#include "c-interface.h"
#include "c-interface-gtk-widgets.h"
#include "cc-interface.hh"
#include "c-interface-preferences.h"

// #include "coot-surface/rgbreps.h"

#include "coot-database.hh"

#include <glob.h>

#ifdef USE_GUILE
#include <libguile.h>
#endif


// #include "c-inner-main.h"
#include "coot-glue.hh"

#include "rotate-translate-modes.hh"

#include "change-dir.hh"
#include "curlew.hh"

void show_citation_request();
void load_gtk_resources();
void setup_splash_screen();
void desensitive_scripting_menu_item_maybe(GtkWidget *window);
int setup_screen_size_settings();
void setup_application_icon(GtkWindow *window);
void setup_symm_lib();
void check_reference_structures_dir();
#include "boot-python.hh"

#ifdef USE_MYSQL_DATABASE
#include "mysql/mysql.h"
int setup_database();
#endif

#include "testing.hh" // for test_internal();

#include "scm-boot-guile.hh"

#include "widget-headers.hh" // put these somewhere else? better name? -------- GTK-FIME
#include "sound.hh"

#include "draw.hh" // for test_gtk3_adjustment_changed() - maybe that should go elsewhere?
#include "draw-2.hh"

#include "dynamic-menus.hh"

#include "widget-from-builder.hh"

void
windows_set_error_mode() {

#ifdef WINDOWS_MINGW
      // in Windows we don't want a crash dialog if no-graphics
      SetErrorMode(SetErrorMode(SEM_NOGPFAULTERRORBOX) | SEM_NOGPFAULTERRORBOX);
#endif // MINGW
}

GtkWidget*
my_create_splash_screen_window (void) {

   GtkWidget *splash_screen_window = gtk_window_new(GTK_WINDOW_POPUP);
   gtk_window_set_title(GTK_WINDOW (splash_screen_window), "Coot");
   gtk_window_set_position(GTK_WINDOW (splash_screen_window), GTK_WIN_POS_CENTER);
#if (GTK_MAJOR_VERSION >=4) || (GTK_MINOR_VERSION == 94)
   gtk_window_set_type_hint(GTK_WINDOW (splash_screen_window), GDK_SURFACE_TYPE_HINT_SPLASHSCREEN);
#else
   gtk_window_set_type_hint(GTK_WINDOW (splash_screen_window), GDK_WINDOW_TYPE_HINT_SPLASHSCREEN);
#endif

   // GtkWidget *image = create_pixmap(splash_screen_window, "coot-0.9.9-pre.png");
   GtkWidget *image = create_pixmap(splash_screen_window, "coot-1.png");
   gtk_widget_show(image);
   gtk_container_add(GTK_CONTAINER(splash_screen_window), image);

   return splash_screen_window;
}


GtkWidget *do_splash_screen(const command_line_data &cld) {

   // 20220313-PE this runs before builder is set.

   GtkWidget *splash_screen = 0;
   setup_splash_screen();

   if (cld.use_splash_screen) {
      if (graphics_info_t::use_graphics_interface_flag) {
         std::string f = cld.alternate_splash_screen_file_name;
         if (f.empty()) {
            splash_screen = my_create_splash_screen_window();
            // splash_screen = widget_from_builder("splash_screen_window");
            // std::cout << "-- in do_splash_screen() splash_screen set to " << splash_screen << std::endl;
         } else {
            splash_screen = create_splash_screen_window_for_file(f.c_str());
         }
         if (splash_screen) {
            gtk_widget_show(splash_screen);
         } else{
            std::cout << "ERROR:: in main() splash is null " << std::endl;
         }

         while(gtk_main_iteration() == FALSE);
         while (gtk_events_pending()) {
            usleep(3000);
            gtk_main_iteration();
         }
      }
   }
   return splash_screen;
}

void
setup_pixmap_directory() {

   // default location:
   std::string dir = coot::package_data_dir();
   std::string dir_2 = coot::util::append_dir_dir(dir, "glade");
   std::string pixmap_dir = coot::util::append_dir_dir(dir_2, "pixmaps");

   // over-ridden by user?
   char *s = getenv("COOT_PIXMAPS_DIR");
   if (s)
      pixmap_dir = s;

   add_pixmap_directory(pixmap_dir.c_str());

}




std::string
make_main_window_title() {

   std::string version_string = VERSION;
   std::string main_title = "Coot " + version_string;
#ifdef MAKE_ENHANCED_LIGAND_TOOLS
   // main_title += " EL";
#endif

#ifdef COOT_MAIN_TITLE_EXTRA
   main_title += COOT_MAIN_TITLE_EXTRA;
#else
   // if this is a pre-release, stick in the revision number too
   if (version_string.find("-pre") != std::string::npos) {
      main_title += " (revision count ";
      main_title += coot::util::int_to_string(git_revision_count());
      main_title += ")";
   }
#endif

#ifdef WINDOWS_MINGW
   main_title = "Win" + main_title;
#endif

   return main_title;
}

int
do_self_tests() {

   std::cout << "INFO:: Running internal self tests" << std::endl;
   // return true on success
   clipper::Test_core test_core;       bool result_core    = test_core();
   clipper::Test_contrib test_contrib; bool result_contrib = test_contrib();
   std::cout<<" INFO:: Test Clipper core   : "<<(result_core   ?"OK":"FAIL")<<std::endl;
   std::cout<<" INFO:: Test Clipper contrib: "<<(result_contrib?"OK":"FAIL")<<std::endl;
   // return 1 on success
   int gis = test_internal();
   int shell_exit_code = 1;
   if (result_core)
      if (result_contrib)
         if (gis == 1)
            shell_exit_code = 0;
   return shell_exit_code;

}

void on_glarea_realize(GtkGLArea *glarea);

// return success status
bool init_from_gtkbuilder() {

   // get the right file first...

   bool status = true;

   std::string dir = coot::package_data_dir();
   std::string dir_glade = coot::util::append_dir_dir(dir, "glade");
   std::string glade_file_full = coot::util::append_dir_file(dir_glade, "a6.glade");

   GtkBuilder *builder = gtk_builder_new();
   if (coot::file_exists("a6.glade"))  // Hack for now
      glade_file_full = "a6.glade";

   const char *env = getenv("COOT_GLADE");
   if (env)
      glade_file_full = std::string(env);

   if (coot::file_exists(glade_file_full)) {
      std::cout << "debug:: file exists " << glade_file_full << std::endl;

      GError *error = NULL;
      gboolean add_from_file_status = gtk_builder_add_from_file(builder, glade_file_full.c_str(), &error);
      if (add_from_file_status == FALSE) {
         std::cout << "ERROR:: Failure to read or parse " << glade_file_full << std::endl;
         std::cout << "ERROR:: " << error->message << std::endl;
         exit(0);
      }
      if (true)
         std::cout << "DEBUG:: init_from_gtkbuilder(): glade file: " << glade_file_full
                   << " add_from_file_status: " << add_from_file_status << std::endl;
   } else {
      std::cout << "debug:: file does not exist " << glade_file_full << std::endl;
      exit(0);
   }

   GtkWidget *graphics_hbox = GTK_WIDGET(gtk_builder_get_object(builder, "main_window_graphics_hbox"));

   // 20220310-PE and the preferences builder too now

   GtkBuilder *preferences_builder = get_builder_for_preferences_dialog();
   graphics_info_t::set_preferences_gtkbuilder(preferences_builder);

   if (graphics_hbox) {

      graphics_info_t::set_gtkbuilder(builder); // store for future widget queries

      GtkWidget *main_window = GTK_WIDGET(gtk_builder_get_object(builder, "main_window"));

      GtkWidget *sb = GTK_WIDGET(gtk_builder_get_object(builder, "main_window_statusbar"));

      GtkWidget *main_window_deletable_label = widget_from_builder("main_window_deletable_label");
      gtk_widget_destroy(main_window_deletable_label);

      if (false) {
         std::cout << "debug:: main_window "   << main_window << std::endl;
         std::cout << "debug:: graphics_hbox " << graphics_hbox << std::endl;
         std::cout << "debug:: statusbar "     << sb << std::endl;
      }

      if (main_window)
         graphics_info_t::set_main_window(main_window);

      std::string main_title = make_main_window_title();
      gtk_window_set_title(GTK_WINDOW(main_window), main_title.c_str());

      graphics_info_t::statusbar = sb;

      create_dynamic_menus(main_window);

      GtkWidget *glarea = create_and_pack_gtkglarea(graphics_hbox, true);
      if (glarea) {
         graphics_info_t::glareas.push_back(glarea);

         GError *err = gtk_gl_area_get_error(GTK_GL_AREA(glarea));
         if (err)
            std::cout << "ERROR:: GL error in init_from_gtkbuilder()" << err << std::endl;

         gtk_builder_connect_signals(builder, main_window);
         gtk_widget_show(main_window);

         if (false) {
            GtkWidget *w = gtk_label_new("Some Test Label");
            gtk_widget_show(w);
            gtk_box_pack_start(GTK_BOX(graphics_hbox), w, FALSE, FALSE, 2);
         }

      } else {
         std::cout << "WARNING:: init_from_gtkbuilder(): glarea null" << std::endl;
         status = false;
      }
   } else {
      std::cout << "WARNING:: init_from_gtkbuilder(): graphics_hbox was null" << std::endl;
      status = false;
   }
   return status;
}

#include "widget-from-builder.hh"

// This main is used for both python/guile useage and unscripted.
int
main(int argc, char *argv[]) {

   auto do_window_resizing_widgets = [] () {

                                        GtkWidget *box = widget_from_builder("main_window_resize_window_button_box");
#ifdef __APPLE__
                                        gtk_widget_show(box);
                                        GtkWidget *window = widget_from_builder("main_window");
                                        // 20220407-PE this causes a crash
                                        // gtk_window_set_has_resize_grip(GTK_WINDOW(main_window), FALSE);

					                         // this expands the window fully in height - I don't want that.
                                        // gtk_window_set_resizable(GTK_WINDOW(window), FALSE);
#else
                                        gtk_widget_hide(box);
#endif
                                     };

   int shell_exit_code = 0;

   graphics_info_t graphics_info;
   graphics_info.coot_is_a_python_module = false;

#ifdef ENABLE_NLS // not used currently in Gtk1. Gkt2, yes.
   //
   bindtextdomain (PACKAGE, PACKAGE_LOCALE_DIR);
   bind_textdomain_codeset (PACKAGE, "UTF-8");
   textdomain (PACKAGE);
#endif

#ifdef USE_LIBCURL
   curl_global_init(CURL_GLOBAL_NOTHING); // nothing extra (e.g. ssl or WIN32)
#endif

   command_line_data cld = parse_command_line(argc, argv);
   cld.handle_immediate_settings(); // sets graphics_info::use_graphics_interface_flag

#ifdef WITH_SOUND
   // test_sound(argc, argv);
#endif // WITH_SOUND

   if (cld.run_internal_tests_and_exit)
      shell_exit_code = do_self_tests();

   if (graphics_info_t::show_citation_notice == 1)
      show_citation_request();

   if (graphics_info_t::use_graphics_interface_flag) {
      // load_gtk_resources();
#if (GTK_MAJOR_VERSION >=4) || (GTK_MINOR_VERSION == 94)
      gtk_init();
#else
      gtk_init(&argc, &argv);
#endif

      // activate to force icons in menus; cannot get it to work with
      // cootrc. Bug?
      // seems to be neccessary to make sure the type is realized
      // and we use newer g_object_set instead of deprecated (gtk3)
      // gtk_settings_set_long_property

      // not sure what this does, but it's deprecated now
      // g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));

      g_object_set(gtk_settings_get_default(), "gtk-menu-images", TRUE, NULL);
      g_object_set(gtk_settings_get_default(), "gtk-application-prefer-dark-theme", TRUE, NULL);

   } else {

      windows_set_error_mode();

   }

   GtkWidget *splash = nullptr;

   if (graphics_info_t::use_graphics_interface_flag)
      splash = do_splash_screen(cld);

   setup_symm_lib();
   check_reference_structures_dir();

   graphics_info.init();

   if (graphics_info_t::use_graphics_interface_flag) {

      setup_pixmap_directory();

      if (cld.use_gtkbuilder) {
         bool success = init_from_gtkbuilder();
         if (success) {
            setup_application_icon(GTK_WINDOW(graphics_info_t::get_main_window()));

            do_window_resizing_widgets();

            if (! graphics_info_t::glareas.empty()) {
               GtkWidget *glarea = graphics_info_t::glareas[0];
               my_glarea_add_signals_and_events(glarea);
               gtk_widget_show(glarea);
               // on_glarea_realize(GTK_GL_AREA(glarea)); // hacketty hack. I don't know why realize is not called
                                                          // without this.
                                                          // 20230105-PE Jakub noticed some problem with GTK4
                                                          // start-up that might be related.
            } else {
               std::cout << "WARNING:: glarea was not initialized! " << std::endl;
            }

            setup_python(argc, argv);
         } else {
            std::cout << "WARNING:: init_from_gtkbuilder() failed " << std::endl;
         }
      }
   } else {
      setup_python(argc, argv);
   }

   // Mac users often start somewhere where they can't write files
   //
   change_directory_maybe();

#if !defined(USE_GUILE) && !defined(USE_PYTHON)
   handle_command_line_data(cld);  // and add a flag if listener
                                   // should be started.
#endif

   if (splash)
      gtk_widget_destroy(splash);

   // before we run the scripting, let's make default preferences
   make_preferences_internal_default();

   // this glade file is derived from an ancient coot. It doesn't have a
   // ligand builder menu item. Add this back when it does.
   //
   // add_ligand_builder_menu_item_maybe();             // FIXME

   // remove Curlew from the File menu with old compiler?
   remove_file_curlew_menu_item_maybe();

   // to start the graphics, we need to init glut and gtk with the
   // command line args.

   // desensitive_scripting_menu_item_maybe(window1);

   // Hack this in to get Python scripts to work - not sure where the correct place to put this is.
   //
#ifdef USE_PYTHON
   handle_command_line_data(cld);
#endif

#ifdef USE_GUILE
   // *Don't* run script from here (before we start guile!)
#else
   //but if ware are using python only, python has been set up before now
   //
   // these scripts are stored by handle_command_line_data()
   run_command_line_scripts();
#endif


   // control goes into my_wrap_scm_boot_guile and doesn't return
#ifdef USE_GUILE
   // Must be the last thing in this function, code after it does not get
   // executed (if we are using guile)
   //
   // std::cout << "------------------------------- into scm_boot_guile we go!" << std::endl;
   my_wrap_scm_boot_guile(argc, argv);
#endif


   // ==================== ususually not exectuted ========================

#if ! defined (USE_GUILE)
#ifdef USE_PYTHON

   if (graphics_info_t::use_graphics_interface_flag)
      gtk_main();
   else {
      start_command_line_python_maybe(true, argc, argv);
   }

#else
   // not python or guile
   if (graphics_info_t::use_graphics_interface_flag)
      gtk_main();
#endif // USE_PYTHON

#endif // ! USE_GUILE

   return shell_exit_code;
}

void desensitive_scripting_menu_item_maybe(GtkWidget *window1) {

   // it's not allowed to build coot without python and guile
}


void load_gtk_resources() {

#if 0
   std::string gtkrcfile = coot::package_data_dir();
   gtkrcfile += "/cootrc";

   // over-ridden by user?
   char *s = getenv("COOT_RESOURCES_FILE");
   if (s) {
      gtkrcfile = s;
   }

   std::cout << "Acquiring application resources from " << gtkrcfile << std::endl;
   gtk_rc_add_default_file(gtkrcfile.c_str()); // Deprecated - use GtkStyleContext
#endif
}


/*  ----------------------------------------------------------------------- */
/*            Amusing (possibly) little splash screen                       */
/*  ----------------------------------------------------------------------- */
void
setup_splash_screen() {

   // default location:
   std::string data_dir = coot::package_data_dir();
   std::string dir_2 = coot::util::append_dir_dir(data_dir, "glade");
   std::string splash_screen_pixmap_dir = coot::util::append_dir_dir(dir_2, "pixmaps");

   // over-ridden by user?
   char *s = getenv("COOT_PIXMAPS_DIR");
   if (s) {
      splash_screen_pixmap_dir = s;
   }

   if (false)
      std::cout << "INFO:: splash_screen_pixmap_dir " << splash_screen_pixmap_dir << std::endl;

   // now add splash_screen_pixmap_dir to the pixmaps_directories CList
   //
   add_pixmap_directory(splash_screen_pixmap_dir.c_str());

}



void
show_citation_request() {

   std::cout << "\n   If you have found this software to be useful, you are requested to cite:\n"
	     << "   Coot: model-building tools for molecular graphics" << std::endl;
   std::cout << "   Emsley P, Cowtan K" << std::endl;
   std::cout << "   ACTA CRYSTALLOGRAPHICA SECTION D-BIOLOGICAL CRYSTALLOGRAPHY\n";
   std::cout << "   60: 2126-2132 Part 12 Sp. Iss. 1 DEC 2004\n\n";

   std::cout << "   The reference for the REFMAC5 Dictionary is:\n";
   std::cout << "   REFMAC5 dictionary: organization of prior chemical knowledge and\n"
	     << "   guidelines for its use" << std::endl;
   std::cout << "   Vagin AA, Steiner RA, Lebedev AA, Potterton L, McNicholas S,\n"
	     << "   Long F, Murshudov GN" << std::endl;
   std::cout << "   ACTA CRYSTALLOGRAPHICA SECTION D-BIOLOGICAL CRYSTALLOGRAPHY " << std::endl;
   std::cout << "   60: 2184-2195 Part 12 Sp. Iss. 1 DEC 2004" << std::endl;

#ifdef HAVE_SSMLIB
    std::cout << "\n   If using \"SSM Superposition\", please cite:\n";

    std::cout << "   Secondary-structure matching (SSM), a new tool for fast\n"
	      << "   protein structure alignment in three dimensions" << std::endl;
    std::cout << "   Krissinel E, Henrick K" << std::endl;
    std::cout << "   ACTA CRYSTALLOGRAPHICA SECTION D-BIOLOGICAL CRYSTALLOGRAPHY" << std::endl;
    std::cout << "   60: 2256-2268 Part 12 Sp. Iss. 1 DEC 2004\n" << std::endl;
#endif // HAVE_SSMLIB

}


void
menutoolbutton_rot_trans_activated(GtkWidget *item, GtkPositionType pos) {

   // std::cout << "changing to zone type" << pos << std::endl;
   set_rot_trans_object_type(pos);
   do_rot_trans_setup(1);
   if (graphics_info_t::model_fit_refine_dialog) {
     update_model_fit_refine_dialog_menu(graphics_info_t::model_fit_refine_dialog);
   }
}

