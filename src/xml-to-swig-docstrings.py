#!/usr/bin/env python3
"""
Convert Doxygen XML output to SWIG %feature("docstring") directives.

This script parses Doxygen XML and generates a .i file that can be 
included in your main SWIG interface file to add rich documentation
to Python bindings.

Usage:
    1. Run Doxygen with XML output enabled
    2. python xml-to-swig-docstrings.py xml/index.xml
    3. Add '%include "coot_docstrings.i"' to your coot.i file
    4. Rebuild SWIG bindings
"""

import xml.etree.ElementTree as ET
import sys
import argparse

def convert_type(tt: str) -> str:
    """Convert C++ types to Python type hints for documentation"""
    if tt == "const ": tt = "str"
    if tt == "const std::string &": tt = "str"
    if tt == "std::string": tt = "str"
    if tt == "unsigned int": tt = "int"
    if tt == "double": tt = "float"
    if tt == 'std::vector< ': tt = "list"
    if tt == 'const std::vector< ': tt = "list"
    if tt == 'const std::vector< float > &': tt = "list"
    if tt == 'std::vector< float > &': tt = "list"
    if tt == "const std::vector< std::string > &": tt = "list"
    if tt == 'const std::map< unsigned int, std::array< float, 3 > > &': tt = "dict"
    if tt == 'const std::map< unsigned int, std::array< float, 4 > > &': tt = "dict"
    if tt == 'const std::vector< std::pair< std::string, unsigned int > > &': tt = "list"
    if tt == 'const coot::residue_spec_t &': tt = 'residue_spec'
    if tt == 'const coot::colour_t &': tt = 'colour'
    if tt == 'const coot::atom_spec_t &': tt = 'atom_spec'
    if tt == 'coot::residue_spec_t &': tt = 'residue_spec'
    if tt == 'std::vector< coot::api::moved_atom_t > &': tt = 'list'
    if tt == 'const std::vector< coot::api::moved_residue_t > &': tt = 'list'
    if tt == 'PyObject *': tt = 'object'
    if tt == 'char const *': tt = 'str'
    if tt == 'short': tt = 'int'
    if tt == 'bool': tt = 'bool'
    if tt == 'int': tt = 'int'
    if tt == 'float': tt = 'float'
    if tt == 'void': tt = 'None'
    
    return tt

def make_swig_docstring(function: dict) -> str:
    """Generate docstring content for SWIG %feature directive"""
    
    doc_parts = []
    
    # Brief description
    if 'briefdescription' in function and function['briefdescription']:
        doc_parts.append(function['briefdescription'].strip())
    
    # Detailed description
    if 'detaileddescription' in function and function['detaileddescription']:
        if doc_parts:  # Add blank line if we had brief description
            doc_parts.append("")
        doc_parts.append(function['detaileddescription'].strip())
    
    # Parameters section (NumPy-style format)
    if 'params' in function and function['params']:
        doc_parts.append("")
        doc_parts.append("Parameters")
        doc_parts.append("----------")
        for param in function['params']:
            param_type = convert_type(param['type'])
            param_name = param['declname']
            doc_parts.append(f"{param_name} : {param_type}")
            # Add parameter description if available
            if 'description' in param and param['description']:
                # Indent parameter descriptions
                desc_lines = param['description'].strip().split('\n')
                for line in desc_lines:
                    doc_parts.append(f"    {line}")
    
    # Return value
    if 'return_description' in function and function['return_description']:
        doc_parts.append("")
        doc_parts.append("Returns")
        doc_parts.append("-------")
        return_type = convert_type(function.get('type', ''))
        if return_type and return_type != 'None':
            doc_parts.append(f"{return_type}")
            doc_parts.append(f"    {function['return_description'].strip()}")
        else:
            doc_parts.append(function['return_description'].strip())
    
    # Examples section if available
    if 'examples' in function and function['examples']:
        doc_parts.append("")
        doc_parts.append("Examples")
        doc_parts.append("--------")
        doc_parts.append(function['examples'].strip())
    
    return "\n".join(doc_parts)

def escape_docstring(docstring: str) -> str:
    """Escape special characters for SWIG docstring"""
    # Escape backslashes and quotes
    docstring = docstring.replace('\\', '\\\\')
    docstring = docstring.replace('"', '\\"')
    return docstring

def make_swig_interface(functions: list, output_file: str = "coot_docstrings.i", 
                        namespace: str = None) -> None:
    """Generate SWIG interface file with docstring features"""
    
    with open(output_file, "w") as f:
        f.write("/* Auto-generated SWIG docstrings from Doxygen XML */\n")
        f.write("/* Generated by xml-to-swig-docstrings.py */\n")
        f.write(f"/* Include this file in your main .i file with: %include \"{output_file}\" */\n\n")
        
        function_count = 0
        
        for function in functions:
            if function.get('kind') != "function":
                continue
            
            func_name = function.get('name', '')
            if not func_name:
                continue
            
            # Skip constructors/destructors (adjust for your class name)
            if func_name.startswith('~'):
                continue
            if namespace and func_name == namespace:
                continue
            
            # Generate docstring
            docstring = make_swig_docstring(function)
            
            if docstring.strip():
                # Escape the docstring
                escaped_docstring = escape_docstring(docstring)
                
                # Write SWIG %feature directive
                f.write(f'%feature("docstring") {func_name} "\n')
                f.write(escaped_docstring)
                f.write('\n";\n\n')
                
                function_count += 1
        
        print(f"✓ Generated SWIG docstrings for {function_count} functions")
        print(f"✓ Output written to: {output_file}")

def parse_doxygen_xml(xml_file: str) -> list:
    """Parse Doxygen XML and extract function information"""
    
    try:
        mytree = ET.parse(xml_file)
    except FileNotFoundError:
        print(f"Error: Cannot find XML file: {xml_file}")
        sys.exit(1)
    except ET.ParseError as e:
        print(f"Error parsing XML: {e}")
        sys.exit(1)
    
    myroot = mytree.getroot()
    functions = []
    
    for x in myroot.iter('sectiondef'):
        for child in x:
            if child.tag == "memberdef":
                keep_going = True
                try:
                    a_function = {}
                    kind = child.attrib.get('kind', '')
                    a_function['kind'] = kind
                    
                    if kind != "function":
                        continue
                    
                    # Extract function details
                    for ch in child:
                        if ch.tag == "definition":
                            # Skip constructors/destructors
                            if "~" in ch.text:
                                keep_going = False
                                break
                        
                        if ch.tag == "name":
                            a_function["name"] = ch.text
                        
                        if ch.tag == "type":
                            a_function["type"] = ch.text
                        
                        if ch.tag == "param":
                            t = ch.find("type")
                            tt = t.text if t is not None else ""
                            dn = ch.find("declname")
                            dn_text = dn.text if dn is not None else ""
                            
                            if 'params' not in a_function:
                                a_function['params'] = []
                            a_function['params'].append({
                                "type": tt, 
                                "declname": dn_text
                            })
                        
                        if ch.tag == "briefdescription":
                            for c in ch:
                                if c.tag == "para" and c.text:
                                    a_function["briefdescription"] = c.text
                        
                        if ch.tag == "detaileddescription":
                            parts = []
                            for c in ch:
                                if c.tag == "para":
                                    if c.text:
                                        parts.append(c.text)
                                    
                                    # Handle parameter descriptions
                                    for chunk in c:
                                        if chunk.tag == "parameterlist":
                                            param_docs = []
                                            for pchunk in chunk:
                                                param_name = ""
                                                param_desc = ""
                                                for cchunk in pchunk:
                                                    if cchunk.tag == "parameternamelist":
                                                        for kchunk in cchunk:
                                                            if kchunk.tag == "parametername":
                                                                param_name = kchunk.text
                                                    if cchunk.tag == "parameterdescription":
                                                        for kchunk in cchunk:
                                                            if kchunk.tag == "para" and kchunk.text:
                                                                param_desc = kchunk.text
                                                
                                                if param_name and param_desc:
                                                    param_docs.append(f":param {param_name}: {param_desc}")
                                            
                                            if param_docs:
                                                parts.append("\n".join(param_docs))
                                        
                                        # Handle return descriptions
                                        if chunk.tag == "simplesect":
                                            if chunk.attrib.get('kind') == 'return':
                                                for kchunk in chunk:
                                                    if kchunk.tag == "para" and kchunk.text:
                                                        a_function["return_description"] = kchunk.text
                            
                            if parts:
                                a_function["detaileddescription"] = "\n\n".join(parts)
                    
                    if keep_going and a_function.get('name'):
                        functions.append(a_function)
                
                except Exception as e:
                    print(f"Warning: Error processing function: {e}")
                    continue
    
    return functions

def main():
    parser = argparse.ArgumentParser(
        description='Convert Doxygen XML to SWIG docstrings',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Process a single class XML file
  python xml-to-swig-docstrings.py xml/classmolecules__container__t.xml
  
  # Process index.xml (processes all classes)
  python xml-to-swig-docstrings.py xml/index.xml -o coot_all_docstrings.i
  
  # Specify output file
  python xml-to-swig-docstrings.py xml/cc-interface.xml -o cc_interface_docs.i
"""
    )
    
    parser.add_argument('xml_file', 
                       help='Doxygen XML file to process (e.g., xml/index.xml)')
    parser.add_argument('-o', '--output', 
                       default='coot_docstrings.i',
                       help='Output .i file (default: coot_docstrings.i)')
    parser.add_argument('-n', '--namespace',
                       help='Class/namespace name (to skip constructor/destructor)')
    
    args = parser.parse_args()
    
    print(f"Parsing Doxygen XML: {args.xml_file}")
    functions = parse_doxygen_xml(args.xml_file)
    
    print(f"Found {len(functions)} functions")
    
    if functions:
        make_swig_interface(functions, args.output, args.namespace)
        print(f"\nNext steps:")
        print(f"1. Add this line to your coot.i file:")
        print(f"   %include \"{args.output}\"")
        print(f"2. Rebuild SWIG bindings")
        print(f"3. Rebuild Coot")
        print(f"4. Restart MCP server to see updated documentation")
    else:
        print("Warning: No functions found in XML file")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
